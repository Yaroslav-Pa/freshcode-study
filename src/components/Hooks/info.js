import { useState, useEffect } from "react";


// useState();

// приймає [значеня] => повертає кортеж = масив з [значенням] та [функцією] *для змінити цього значення

const [age, setAge] = useState(42);

// АЛЕ
// якщо робити об'єктом
let [state, setState] = useState({ nowClicks: 0, step: 1 });
// то setState буде преезаписувати повністю УВЕСЬ об'єкт
// тож якщо робити оновлення чогось потрібно писати:
setState({ ...state, nowClicks: state.nowClicks + state.step });

//це не поганий варіант тільки якщо ти будеш оновлювати одразу всі значення у об'єкті
// наприклад коли потрібно відсліжувати мишку та потрібно {x, y} постійно оновлювати


// краще розбити цей об'єкт на два useState
let [nowClicks, setNowClicks] = useState(0);
let [step, setStep] = useState( 1 );

//**об'єкти краще обробляти іншою штукою





// useEffect()
/*
запускається після рендеру компоненту
без значення буде поєднанням didMount та DidUpdate
*/
useEffect(fun(){return fun2()})
/*
якщо передавати у useEffect ФВП(що буде повертати функцію), ця фунція що повертається 
буде запускатись перед:
розмонтуванням компоненту (willUnmount) + перед кожним запуском Effect ререндером
↑ Це відбувається через те що функція що повернулась має бути замінена наступною що поверниться, тож він її визиває та записує нову що повернулась
*/


useEffect(fun(), []);
/* 
[] другий аргумент = масив залежностей, в нього кидати усе на update чого цей useEffect має запуститись 
якщо просто передати [] = запуск буде тільки на старті (didMount) й якщо було заретунено функцію то виконається один раз як компонент скроється (willUnmount)
*/

useEffect(fun(){return a+b}, []);
/*
!!! (або якщо fun() щось бере зовні) за логікою замикання він бере значення які були у момент його стоворення
тож якщо при старті a=0 b=1 поверене 1, а має тепер бути 1, але ні, він цього не бачить, й бачить що а=0 все ще й так по кругу

щоб це вилікувати потрібно у масив покласти a та b = useEffect(fun(){a+b},[a,b]);*/






import { UserContext } from './contexts';
<UserContext.Provider value={user}>
  <Something></Something>
  <Something2></Something2>
  <Something3></Something3>
</UserContext.Provider>


const ContactsPage = () => {
  // useContext приймає об'єкт контексту і повертає дані які у ньому знаходяться
  // при зміні даних буде відбуватися ререндер автоматично
  const user = useContext(UserContext);
  return {
    <p>{user}</p>
  }
}







useCustome();
// Користувацьким хуком є проста функція, що починається з use та може використовувати хуки у середені себе. 
// *Ну й має повертати данні типу [data1, data2], але це не офіцал умова