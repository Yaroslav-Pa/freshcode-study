24.11.23

  CW-array_2th-24.11.23.js

  

  let arr = ['a','b','c','d','f']

   = arr.join('\\__/') // повертає string з'єднаних елементів масиву, через елемент у параметрах
  
   = arr.includes('a'); // повертає bool чи є там щось що було передано у параметрах

   arr.reverse(); // перекручує масив (та може повернути перекручений масив)



  let deeeeepArray = [1, 1, 1, [2, 2, [3, 3, [4, 4]]]];
  console.log(deeeeepArray[3][2][2][0]); // 4 // прикладяк звернутись до масиву у масиву..

    const flat1 = deeeeepArray.flat(1); //[1, 1, 1, 2, 2, [3, 3, [4, 4]]]
    const flat1 = deeeeepArray.flat(3); //[1, 1, 1, 2, 2, 3, 3, 4, 4]
    // "розрівнює" вказану у параметках глибину масивів у вибораному масиву, не змінює сам масив
    // можна писати Infinity для того щоб не шукати кількість слоїв


    //Код, наприклад
    const concat1 = arr.concat('Fedor', 'Json'); //закидує усе у вибраний масив
    const concat2 = arr.concat('Fedor', 'Json', ['Fedor', 'Json']); //може розкрити масив що йому передають
    const concat3 = arr.concat('Fedor', 'Json', ['Fedor', 'Json' ['Fedo3', 'Json3']]); //але лише 1 у глубь
  




  мутуючі та не мутуючі функції масивів

  мутуючі функції - функції що змінюють об'єкт (з якого беруть данні)
  не мутуючі функції - що не змінюють об'єкт з якого беруть данні

  callback функція - це функція що запускається іншою функцією





  .forEach
  const users = [{id:0},{id:1},{id:2},{id:3}]

  const showEveryUser = (user, curentIndex, allArray) => {
    console.log(user); //поточний елемент
    console.log(curentIndex); //індекс поточного елемету
    console.log(allArray); //сам масив по якому ходимо
  }
  

  users.forEach(showEveryUser); // за допомогою callback функції передає у задану функцію: поточний елемент, індекс поточного елемету, сам масив по якому ходимо.


//код

  //map
const NewArray = testArray.map( (numb) => { //дуже схожа на forEach але записує значення що повртаються, повертає ту саму ж кількість об'єктів що й війшла
  return numb**4;
})



const users = ['Anton2', 'Andray', 'Hodof', 'Gendalf', 'Anton']

//filter
const betterUsers = users.filter( (name) => { // може повернути не всі об'єкти що увейшли
  // if (name !== Anton){
  //   return true; //опиниться у новому масиву
  // }else{
  //   return false; //не опиниться у новому масиву
  // }
  return (name !== 'Anton');
})


//some 
//(буквально if(item1 === "something" || item2 === "something"...))
const isAntonIn = users.some((name)=>{ //повертає bool якщо деякий === чомусь
  return name ==='Anton';
})


//every 
//(буквально if(item1 === "something" && item2 === "something"...))
const isEveryAnton = users.some((name)=>{ //повертає bool якщо усі === чомусь
  return name ==='Anton';
})

//find 
// повертає перший елемент масива що === чомусь
const firstAnton = users.find((name) => {
  return name ==='Anton'
})

//findIndex 
// повертає індекс першого елементу масива що === чомусь
const indexAnton = users.findIndex((name) => {
  return name ==='Anton'
})
// !!! якщо не знайде відповідний елемет поверне значення -1

//indexOf
// повертає індекс першого елементу масива що === переданому значенню
const indexAnton2 = users.indexOf('Anton')